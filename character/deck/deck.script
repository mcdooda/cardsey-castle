go.property("is_player_deck", true)

local cards = require("card.cards")

function init(self)
	self.stack = cards.init_stack()
end

function on_message(self, message_id, message, sender)
	if message_id == hash("draw") then
		if #self.stack == 0 then
			return
		end
		local show_front = message.show_front
		local amount = math.min(message.amount, #self.stack)
		for i = 1, amount do
			local top_card_name = self.stack[#self.stack]
			self.stack[#self.stack] = nil
			local position = go.get_position()
			local rotation = go.get_rotation()
			local scale = go.get_scale()
			local properties = {
				card_name = top_card_name,
				character = msg.url("character")
			}
			local card = factory.create("#card-factory", position, rotation, properties, scale)
			msg.post(msg.url(nil, card, "collisionobject"), "disable")
			msg.post(msg.url(nil, card, "cards-collision"), "disable")
			local draw_position_url = self.is_player_deck and msg.url("draw-position-player") or msg.url("draw-position-enemy")
			local card_destination_position = go.get_position(draw_position_url)
			go.animate(msg.url(nil, card, nil), "position.x", go.PLAYBACK_ONCE_FORWARD, card_destination_position.x, go.EASING_INOUTCUBIC, 0.4, (i - 1) * 0.2)
			go.animate(msg.url(nil, card, nil), "position.y", go.PLAYBACK_ONCE_FORWARD, card_destination_position.y, go.EASING_INOUTCUBIC, 0.4, (i - 1) * 0.2, function()
				msg.post(msg.url(nil, card, "collisionobject"), "enable")
				msg.post(msg.url(nil, card, "cards-collision"), "enable")
				if show_front then
					msg.post(msg.url(nil, card, nil), "show_front")
				end
			end)
		end
	end
end