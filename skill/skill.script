go.property("skill_name", hash("test_skill_1"))
go.property("card_player", msg.url("/character-player"))
go.property("opponent", msg.url("/character-enemy"))
go.property("used", false)

local skills = require("skill.skills")

function init(self)
	self.skill = assert(skills[self.skill_name], "cannot find card " .. tostring(self.skill_name))
	label.set_text("#requirements-label", self.skill.requirements)
	label.set_text("#description-label", self.skill.description)
	msg.post(self.card_player, "add_skill", { skill_id = msg.url("#") })
	self.initial_y = go.get_position().y

	go.set_parent("skill-background", msg.url("."), true)
end

local function can_play_card(self, card)
	local card_script_url = msg.url(nil, card, "card")
	local card_name
	local showing_front = go.get(card_script_url, "showing_front")
	if showing_front then
		card_name = go.get(card_script_url, "card_name")
	end
	return self.skill:can_play_card(card_name)
end

local function execute_skill(self, card)
	local card_script_url = msg.url(nil, card.path, "card")
	local card_name = go.get(card_script_url, "card_name")
	local showing_front = go.get(card_script_url, "showing_front")
	
	local card_player_script_url = msg.url(nil, self.card_player.path, "character")
	local opponent_script_url = msg.url(nil, self.opponent.path, "character")
	
	self.skill:execute(self, card_name, showing_front, card_player_script_url, opponent_script_url, msg.url("#"))
end

local function shake(self)
	go.animate(".", "euler.z", go.PLAYBACK_ONCE_FORWARD, 3, go.EASING_LINEAR, 0.04, 0, function()
		go.animate(".", "euler.z", go.PLAYBACK_ONCE_FORWARD, -3, go.EASING_LINEAR, 0.08, 0, function()
			go.animate(".", "euler.z", go.PLAYBACK_ONCE_FORWARD, 0, go.EASING_LINEAR, 0.04)
		end)
	end)
end

function on_message(self, message_id, message, sender)
	if message_id == hash("trigger_response") then
		local card = message.other_id
		if message.enter then
			if can_play_card(self, card) then
				msg.post(card, "entered_skill", { skill_id = msg.url(".") })
			else
				shake(self)
			end
		else
			if can_play_card(self, card) then
				msg.post(message.other_id, "left_skill")
			end
		end
	elseif message_id == hash("execute_skill") then
		if self.used then
			return
		end
		self.used = true
		local card = message.card_id
		msg.post(msg.url(nil, card.path, "collisionobject"), "disable")
		msg.post(msg.url(nil, card.path, "cards-collision"), "disable")
		go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, self.initial_y + 1600, go.EASING_INBACK, 0.4, 0, function()
			execute_skill(self, card)
			msg.post("/hand", "remove_card", { card_id = card })
		end)
	elseif message_id == hash("reload_skill") then
		if not self.used then
			return
		end
		self.used = false
		go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, self.initial_y, go.EASING_INBACK, 0.4)
	end
end
