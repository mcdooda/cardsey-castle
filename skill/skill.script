go.property("skill_name", hash("test_skill_1"))

local skills = require("skill.skills")

function init(self)
	self.skill = assert(skills[self.skill_name], "cannot find card " .. tostring(self.skill_name))
	label.set_text("#requirements-label", self.skill.requirements)
	label.set_text("#description-label", self.skill.description)
end

local function can_play_card(self, card)
	local card_script_url = msg.url(nil, card, "card")
	local card_name = go.get(card_script_url, "card_name")
	local showing_front = go.get(card_script_url, "showing_front")
	return self.skill:can_play_card(card_name, showing_front)
end

local function execute_skill(self, card)
	local card_script_url = msg.url(nil, card.path, "card")
	local card_name = go.get(card_script_url, "card_name")
	local showing_front = go.get(card_script_url, "showing_front")
	self.skill:execute(self, card_name, showing_front)
end

local function shake(self)
	go.animate(".", "euler.z", go.PLAYBACK_ONCE_FORWARD, 3, go.EASING_LINEAR, 0.04, 0, function()
		go.animate(".", "euler.z", go.PLAYBACK_ONCE_FORWARD, -3, go.EASING_LINEAR, 0.08, 0, function()
			go.animate(".", "euler.z", go.PLAYBACK_ONCE_FORWARD, 0, go.EASING_LINEAR, 0.04)
		end)
	end)
end

function on_message(self, message_id, message, sender)
	if message_id == hash("trigger_response") then
		local card = message.other_id
		if message.enter then
			if can_play_card(self, card) then
				msg.post(card, "entered_skill", { skill_id = msg.url(".") })
			else
				shake(self)
			end
		else
			if can_play_card(self, card) then
				msg.post(message.other_id, "left_skill")
			end
		end
	elseif message_id == hash("execute_skill") then
		local card = message.card_id
		go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, go.get_position().z + 1600, go.EASING_INBACK, 0.4, 0, function()
			execute_skill(self, card)
		end)
	end
end
