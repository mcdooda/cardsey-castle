go.property("skill_name", hash("test_skill_1"))
go.property("card_player", msg.url())
go.property("opponent", msg.url())
go.property("used", false)

local skills = require("skill.skills")

function init(self)
	self.skill = assert(skills[self.skill_name], "cannot find card " .. tostring(self.skill_name))
	label.set_text("#requirements-label", self.skill.requirements)
	label.set_text("#description-label", self.skill.description)
	self.initial_y = go.get_position().y

	go.set_parent("skill-background", msg.url("."), true)
end

local function can_play_card(self, card)
	local card_script_url = msg.url(nil, card, "card")
	local card_name
	local showing_front = go.get(card_script_url, "showing_front")
	if showing_front then
		card_name = go.get(card_script_url, "card_name")
	end
	return self.skill:can_play_card(card_name)
end

local function prepare_skill(self, card, decision)
	local card_script_url = msg.url(nil, card.path, "card")
	local card_name = go.get(card_script_url, "card_name")
	local showing_front = go.get(card_script_url, "showing_front")
	return self.skill:prepare(card_name, showing_front, self.card_player, self.opponent, msg.url("#"), decision)
end

local function execute_skill(self, card, decision)
	local card_script_url = msg.url(nil, card.path, "card")
	local card_name = go.get(card_script_url, "card_name")
	local showing_front = go.get(card_script_url, "showing_front")
	self.skill:execute(card_name, showing_front, self.card_player, self.opponent, msg.url("#"), decision)
end

local function shake(self)
	go.animate(".", "euler.z", go.PLAYBACK_ONCE_FORWARD, 3, go.EASING_LINEAR, 0.04, 0, function()
		go.animate(".", "euler.z", go.PLAYBACK_ONCE_FORWARD, -3, go.EASING_LINEAR, 0.08, 0, function()
			go.animate(".", "euler.z", go.PLAYBACK_ONCE_FORWARD, 0, go.EASING_LINEAR, 0.04)
		end)
	end)
end

function on_message(self, message_id, message, sender)
	if message_id == hash("trigger_response") then
		local card = message.other_id
		if go.get(msg.url(nil, card, "card"), "character") == self.card_player then
			if message.enter then
				if can_play_card(self, card) then
					msg.post(card, "entered_skill", { skill_id = msg.url(".") })
					--go.set("skill-background#rectangle", "color", vmath.vector4(0.4, 1, 0.4, 1))
				else
					if go.get(msg.url(nil, self.card_player.path, "character"), "is_player") then
						shake(self)
					end
					--go.set("skill-background#rectangle", "color", vmath.vector4(1, 0.4, 0.4, 1))
				end
			else
				if can_play_card(self, card) then
					msg.post(message.other_id, "left_skill", { skill_id = msg.url(".") })
				end
				--go.set("skill-background#rectangle", "color", vmath.vector4(0.4, 0.74, 1, 1))
			end
		end
	elseif message_id == hash("execute_skill") then
		if self.used then
			return
		end
		self.used = true
		local card = message.card_id
		msg.post(msg.url(nil, card.path, "collisionobject"), "disable")
		msg.post(msg.url(nil, card.path, "cards-collision"), "disable")
		
		local decision = {}
		local target_character = prepare_skill(self, card, decision)
		
		local y
		if go.get(msg.url(nil, target_character.path, "character"), "is_player") then
			y = self.initial_y - 1600
		else
			y = self.initial_y + 1600
		end
		go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, y, go.EASING_INBACK, 0.4, 0, function()
			execute_skill(self, card, decision)
			msg.post(self.card_player, "remove_card", { card_id = card })

			if not go.get(msg.url(nil, self.card_player.path, "character"), "is_player") then
				timer.delay(1, false, function()
					msg.post(self.card_player, "play_ai_turn")
				end)
			end
		end)
	elseif message_id == hash("reload_skill") then
		if not self.used then
			return
		end
		self.used = false
		go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, self.initial_y, go.EASING_INBACK, 0.4)
	end
end
